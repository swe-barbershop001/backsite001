name: ðŸš€ CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  DOCKER_IMAGE_NAME: barbershop-bot
  APP_DIR: /home/ubuntu/barbershop-bot

jobs:
  # ============================================
  # Job 1: Setup - Checkout and Verify
  # ============================================
  setup:
    name: ðŸ“‹ Setup & Verify
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.branch.outputs.name }}
      sha: ${{ steps.sha.outputs.short }}
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Get branch name
        id: branch
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "name=${{ github.head_ref }}" >> $GITHUB_OUTPUT
          else
            echo "name=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ” Get short SHA
        id: sha
        run: echo "short=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: âœ… Verify branch
        run: |
          BRANCH="${{ steps.branch.outputs.name }}"
          echo "Current branch: $BRANCH"
          if [ "${{ github.event_name }}" = "push" ] && [ "$BRANCH" != "main" ]; then
            echo "âš ï¸ Warning: Not on main branch, but continuing..."
          fi
          echo "âœ… Branch verification passed"

      - name: ðŸ“Š Workflow info
        run: |
          echo "ðŸ”¹ Repository: ${{ github.repository }}"
          echo "ðŸ”¹ Branch: ${{ steps.branch.outputs.name }}"
          echo "ðŸ”¹ Commit SHA: ${{ steps.sha.outputs.short }}"
          echo "ðŸ”¹ Event: ${{ github.event_name }}"

  # ============================================
  # Job 2: Build - Install, Build, Save Image
  # ============================================
  build:
    name: ðŸ—ï¸ Build Docker Image
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.meta.outputs.digest }}
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ“¦ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¥ Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          npm ci
          echo "âœ… Dependencies installed successfully"

      - name: ðŸ” Run linter
        run: |
          echo "ðŸ” Running ESLint..."
          npm run lint || echo "âš ï¸ Lint warnings found (non-blocking)"

      - name: ðŸ—ï¸ Build application
        run: |
          echo "ðŸ—ï¸ Building application..."
          npm run build
          echo "âœ… Application built successfully"

      - name: ðŸ³ Extract metadata
        id: meta
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          echo "tags=$IMAGE_TAG,$IMAGE_LATEST" >> $GITHUB_OUTPUT
          echo "ðŸ”¹ Image tags: $IMAGE_TAG, $IMAGE_LATEST"

      - name: ðŸ³ Build Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          
          echo "ðŸ³ Building Docker image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG -t $IMAGE_LATEST .
          
          echo "âœ… Docker image built successfully"
          docker images | grep "${{ env.DOCKER_IMAGE_NAME }}"

      - name: ðŸ’¾ Save Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar"
          
          echo "ðŸ’¾ Saving Docker image to $IMAGE_FILE..."
          docker save $IMAGE_TAG -o $IMAGE_FILE
          
          # Compress the image to reduce size
          echo "ðŸ—œï¸ Compressing image..."
          gzip -f $IMAGE_FILE
          
          echo "âœ… Image saved and compressed: ${IMAGE_FILE}.gz"
          ls -lh ${IMAGE_FILE}.gz

      - name: ðŸ“¤ Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: docker-image-${{ needs.setup.outputs.sha }}.tar.gz
          retention-days: 1
          compression-level: 0

      - name: ðŸ“Š Build summary
        run: |
          echo "### ðŸ—ï¸ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Name:** ${{ env.DOCKER_IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 3: Deploy - SSH to EC2 and Deploy
  # ============================================
  deploy:
    name: ðŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: ./

      - name: ðŸ” Setup SSH key and test connection
        run: |
          set -e
          
          # Display connection info (without exposing secrets)
          echo "ðŸ” SSH Connection Configuration:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          DEPLOY_HOST="${{ secrets.DEPLOY_HOST }}"
          DEPLOY_USER="${{ secrets.DEPLOY_USER }}"
          DEPLOY_PORT="${{ secrets.DEPLOY_PORT || 22 }}"
          
          echo "ðŸ“ Host: $DEPLOY_HOST"
          echo "ðŸ‘¤ User: $DEPLOY_USER"
          echo "ðŸ”Œ Port: $DEPLOY_PORT"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Setup SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Save SSH key
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify SSH key format
          echo ""
          echo "ðŸ”‘ Verifying SSH key format..."
          if grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            KEY_TYPE=$(grep -o "BEGIN [A-Z ]*PRIVATE KEY" ~/.ssh/deploy_key | head -1)
            echo "âœ… SSH key format detected: $KEY_TYPE"
            KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
            echo "ðŸ“ Key length: $KEY_LINES lines"
          else
            echo "âŒ ERROR: SSH key format is invalid!"
            echo "Expected: -----BEGIN ... PRIVATE KEY-----"
            echo "First 50 chars of key:"
            head -c 50 ~/.ssh/deploy_key
            echo ""
            exit 1
          fi
          
          # Test host connectivity
          echo ""
          echo "ðŸŒ Testing host connectivity..."
          if timeout 10 bash -c "echo > /dev/tcp/$DEPLOY_HOST/$DEPLOY_PORT" 2>/dev/null; then
            echo "âœ… Host $DEPLOY_HOST:$DEPLOY_PORT is reachable"
          else
            echo "âš ï¸  WARNING: Cannot reach $DEPLOY_HOST:$DEPLOY_PORT"
            echo "   This might be normal if firewall blocks TCP checks"
          fi
          
          # Add host to known_hosts
          echo ""
          echo "ðŸ” Adding host to known_hosts..."
          ssh-keyscan -p $DEPLOY_PORT -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>&1 || {
            echo "âš ï¸  Warning: ssh-keyscan failed, but continuing..."
          }
          
          # Test SSH connection with retry and detailed error messages
          echo ""
          echo "ðŸ” Testing SSH connection..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          CONNECTED=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ”„ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Try SSH connection with verbose output
            echo "ðŸ”Œ Attempting SSH connection..."
            echo "Command: ssh -i ~/.ssh/deploy_key -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST"
            
            # Check key permissions
            KEY_PERM=$(stat -c "%a" ~/.ssh/deploy_key 2>/dev/null || stat -f "%OLp" ~/.ssh/deploy_key 2>/dev/null || echo "unknown")
            echo "ðŸ” Key permissions: $KEY_PERM (should be 600)"
            
            # Try SSH connection with full verbose output
            SSH_OUTPUT=$(ssh -vvv -i ~/.ssh/deploy_key \
                   -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=~/.ssh/known_hosts \
                   -o ConnectTimeout=30 \
                   -o ServerAliveInterval=60 \
                   -o ServerAliveCountMax=3 \
                   -p $DEPLOY_PORT \
                   $DEPLOY_USER@$DEPLOY_HOST \
                   "echo 'SSH connection successful!'" 2>&1)
            
            SSH_EXIT_CODE=$?
            
            if [ $SSH_EXIT_CODE -eq 0 ]; then
              CONNECTED=true
              echo "âœ… SSH connection successful!"
              echo "$SSH_OUTPUT" | tail -10
              break
            else
              echo "âŒ SSH connection failed (exit code: $SSH_EXIT_CODE)"
              echo ""
              echo "ðŸ“‹ Full SSH verbose output:"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "$SSH_OUTPUT"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo ""
              echo "ðŸ” Key error messages:"
              echo "$SSH_OUTPUT" | grep -iE "error|failed|denied|timeout|refused|permission|authentication|connection|unreachable|no route" | head -10 || echo "No specific error messages found"
              
              # Common error analysis
              if echo "$SSH_OUTPUT" | grep -qi "Permission denied"; then
                echo ""
                echo "âš ï¸  PERMISSION DENIED - Possible causes:"
                echo "   1. Wrong SSH key (not matching EC2 key pair)"
                echo "   2. Wrong username (should be 'ubuntu' for Ubuntu, 'ec2-user' for Amazon Linux)"
                echo "   3. SSH key format issue"
              fi
              
              if echo "$SSH_OUTPUT" | grep -qi "Connection refused\|Connection timed out"; then
                echo ""
                echo "âš ï¸  CONNECTION REFUSED/TIMEOUT - Possible causes:"
                echo "   1. EC2 instance is not running"
                echo "   2. Security Group doesn't allow SSH (port $DEPLOY_PORT)"
                echo "   3. Wrong host/IP address"
                echo "   4. Firewall blocking connection"
              fi
              
              if echo "$SSH_OUTPUT" | grep -qi "Host key verification failed"; then
                echo ""
                echo "âš ï¸  HOST KEY VERIFICATION FAILED - This should be handled by StrictHostKeyChecking=no"
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo ""
                echo "â³ Waiting 5 seconds before retry..."
                sleep 5
              fi
            fi
          done
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if [ "$CONNECTED" = false ]; then
            echo "âŒ SSH connection failed after $MAX_RETRIES attempts"
            echo ""
            echo "ðŸ“‹ Troubleshooting Checklist:"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "1. âœ… EC2 instance is running"
            echo "   Check: AWS Console â†’ EC2 â†’ Instances"
            echo ""
            echo "2. âœ… Security Group allows SSH"
            echo "   Port: $DEPLOY_PORT"
            echo "   Source: 0.0.0.0/0 (or GitHub Actions IP range)"
            echo "   Check: EC2 â†’ Security Groups â†’ Inbound Rules"
            echo ""
            echo "3. âœ… DEPLOY_HOST is correct"
            echo "   Current: $DEPLOY_HOST"
            echo "   Should be: EC2 Public IP or Public DNS"
            echo ""
            echo "4. âœ… DEPLOY_USER is correct"
            echo "   Current: $DEPLOY_USER"
            echo "   Ubuntu: ubuntu"
            echo "   Amazon Linux: ec2-user"
            echo ""
            echo "5. âœ… SSH key is correct"
            echo "   Format: -----BEGIN ... PRIVATE KEY-----"
            echo "   Should match the key pair used when creating EC2 instance"
            echo ""
            echo "6. âœ… Test connection manually:"
            echo "   ssh -i your-key.pem $DEPLOY_USER@$DEPLOY_HOST -p $DEPLOY_PORT"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            exit 1
          fi

      - name: ðŸš€ Deploy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "docker-image-${{ needs.setup.outputs.sha }}.tar.gz,docker-compose.yml"
          target: ${{ env.APP_DIR }}
          timeout: 600s
          command_timeout: 600s
          debug: true
          strip_components: 0
          overwrite: true
          use_insecure_cipher: false

      - name: ðŸ³ Deploy Docker containers
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          timeout: 900s
          command_timeout: 900s
          debug: true
          use_insecure_cipher: false
          script: |
            set -e
            
            APP_DIR="${{ env.APP_DIR }}"
            IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
            IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar.gz"
            
            echo "ðŸš€ Starting deployment..."
            echo "ðŸ“ App directory: $APP_DIR"
            echo "ðŸ³ Image tag: $IMAGE_TAG"
            echo "ðŸ“¦ Image file: $IMAGE_FILE"
            
            # Create app directory if it doesn't exist
            mkdir -p $APP_DIR
            cd $APP_DIR
            echo "âœ… Changed to directory: $(pwd)"
            
            # Ensure Docker and Docker Compose are installed
            if ! command -v docker &> /dev/null; then
              echo ">> Docker o'rnatilmagan, o'rnatilmoqda..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
              echo ">> Docker muvaffaqiyatli o'rnatildi"
            else
              echo ">> Docker allaqachon o'rnatilgan"
            fi
            
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo ">> Docker Compose o'rnatilmagan, o'rnatilmoqda..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
              echo ">> Docker Compose muvaffaqiyatli o'rnatildi"
            else
              echo ">> Docker Compose allaqachon o'rnatilgan"
            fi
            
            # Load Docker image (use sudo if needed, or newgrp for docker group)
            echo "ðŸ“¥ Loading Docker image..."
            if groups | grep -q docker; then
              DOCKER_CMD="docker"
              COMPOSE_CMD="docker-compose"
            else
              DOCKER_CMD="sudo docker"
              COMPOSE_CMD="sudo docker-compose"
              echo "âš ï¸ Using sudo for docker commands (user not in docker group yet)"
            fi
            
            # Check if image file exists
            if [ ! -f "$IMAGE_FILE" ]; then
              echo "âŒ Image file not found: $IMAGE_FILE"
              echo "ðŸ“‚ Current directory contents:"
              ls -la
              exit 1
            fi
            
            echo "ðŸ“¦ Loading image from $IMAGE_FILE..."
            gunzip -c $IMAGE_FILE | $DOCKER_CMD load
            $DOCKER_CMD tag $IMAGE_TAG ${{ env.DOCKER_IMAGE_NAME }}:latest
            echo "âœ… Docker image loaded successfully"
            echo "ðŸ“‹ Available images:"
            $DOCKER_CMD images | grep "${{ env.DOCKER_IMAGE_NAME }}" || true
            
            # Stop old containers
            echo "ðŸ›‘ Stopping old containers..."
            if [ -f docker-compose.yml ]; then
              $COMPOSE_CMD down || true
            fi
            
            # Create .env file
            echo "ðŸ“ Creating .env file..."
            cat > .env << EOF
            # Telegram Bot Configuration
            BOT_TOKEN=${{ secrets.BOT_TOKEN }}
            
            # SUPER_ADMIN Configuration
            SUPER_ADMIN_USERNAME=${{ vars.SUPER_ADMIN_USERNAME }}
            SUPER_ADMIN_PASSWORD=${{ secrets.SUPER_ADMIN_PASSWORD }}
            SUPER_ADMIN_NAME=${{ vars.SUPER_ADMIN_NAME }}
            SUPER_ADMIN_PHONE=${{ vars.SUPER_ADMIN_PHONE }}
            
            # Token
            JWT_TOKEN_SECRET=${{ secrets.JWT_TOKEN_SECRET }}
            JWT_TOKEN_EXPIRATION=${{ vars.JWT_TOKEN_EXPIRATION }}
            
            # Database Configuration (Docker Compose service nomi)
            DB_HOST=db
            DB_PORT=${{ vars.DB_PORT }}
            DB_USERNAME=${{ vars.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ vars.DB_DATABASE }}
            
            # Application Port
            PORT=${{ vars.PORT }}
            NODE_ENV=production
            EOF
            
            # Update docker-compose.yml to use image instead of build
            echo "ðŸ”§ Updating docker-compose.yml to use pre-built image..."
            IMAGE_NAME="${{ env.DOCKER_IMAGE_NAME }}:latest"
            # Use awk to replace build section with image (more reliable than sed for multi-line)
            awk -v img="$IMAGE_NAME" '
            /^  app:/ { in_app=1; print; next }
            in_app && /^    build:/ { 
              print "    image: " img
              skip_build=1
              next
            }
            skip_build && /^      (context|dockerfile):/ { next }
            skip_build && /^    [a-z]/ { skip_build=0; in_app=0 }
            { print }
            ' docker-compose.yml > docker-compose.yml.tmp && mv docker-compose.yml.tmp docker-compose.yml
            echo "âœ… docker-compose.yml updated to use image: $IMAGE_NAME"
            
            # Clean up old images
            echo "ðŸ§¹ Cleaning up old images..."
            $DOCKER_CMD image prune -f || true
            
            # Start containers
            echo "ðŸš€ Starting containers..."
            $COMPOSE_CMD up -d
            
            # Wait for database to be ready
            echo "â³ Waiting for database to be ready..."
            timeout=60
            counter=0
            while ! $COMPOSE_CMD exec -T db pg_isready -U ${{ vars.DB_USERNAME }} > /dev/null 2>&1; do
              if [ $counter -ge $timeout ]; then
                echo "âŒ Database container tayyor bo'lmadi!"
                exit 1
              fi
              echo "Database kutilyapti... ($counter/$timeout)"
              sleep 2
              counter=$((counter + 2))
            done
            echo "âœ… Database container tayyor!"
            
            # Show container status
            echo "ðŸ“Š Container status:"
            $COMPOSE_CMD ps
            
            # Show database volume info
            echo "ðŸ’¾ Database volume info:"
            $DOCKER_CMD volume inspect postgres_data 2>/dev/null || echo "Volume info not available"
            
            echo "âœ… Deployment completed successfully!"

      - name: ðŸ“Š Deployment summary
        run: |
          echo "### ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Server:** ${{ secrets.DEPLOY_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** http://${{ secrets.DEPLOY_HOST }}:${{ vars.PORT }}" >> $GITHUB_STEP_SUMMARY
