name: ðŸš€ CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  DOCKER_IMAGE_NAME: barbershop-bot
  APP_DIR: /home/ubuntu/barbershop-bot

jobs:
  # ============================================
  # Job 1: Setup - Checkout and Verify
  # ============================================
  setup:
    name: ðŸ“‹ Setup & Verify
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.branch.outputs.name }}
      sha: ${{ steps.sha.outputs.short }}
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Get branch name
        id: branch
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "name=${{ github.head_ref }}" >> $GITHUB_OUTPUT
          else
            echo "name=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ” Get short SHA
        id: sha
        run: echo "short=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: âœ… Verify branch
        run: |
          BRANCH="${{ steps.branch.outputs.name }}"
          echo "Current branch: $BRANCH"
          if [ "${{ github.event_name }}" = "push" ] && [ "$BRANCH" != "main" ]; then
            echo "âš ï¸ Warning: Not on main branch, but continuing..."
          fi
          echo "âœ… Branch verification passed"

      - name: ðŸ“Š Workflow info
        run: |
          echo "ðŸ”¹ Repository: ${{ github.repository }}"
          echo "ðŸ”¹ Branch: ${{ steps.branch.outputs.name }}"
          echo "ðŸ”¹ Commit SHA: ${{ steps.sha.outputs.short }}"
          echo "ðŸ”¹ Event: ${{ github.event_name }}"

  # ============================================
  # Job 2: Build - Install, Build, Save Image
  # ============================================
  build:
    name: ðŸ—ï¸ Build Docker Image
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.meta.outputs.digest }}
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ“¦ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¥ Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          npm ci
          echo "âœ… Dependencies installed successfully"

      - name: ðŸ” Run linter
        run: |
          echo "ðŸ” Running ESLint..."
          npm run lint || echo "âš ï¸ Lint warnings found (non-blocking)"

      - name: ðŸ—ï¸ Build application
        run: |
          echo "ðŸ—ï¸ Building application..."
          npm run build
          echo "âœ… Application built successfully"

      - name: ðŸ³ Extract metadata
        id: meta
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          echo "tags=$IMAGE_TAG,$IMAGE_LATEST" >> $GITHUB_OUTPUT
          echo "ðŸ”¹ Image tags: $IMAGE_TAG, $IMAGE_LATEST"

      - name: ðŸ³ Build Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          
          echo "ðŸ³ Building Docker image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG -t $IMAGE_LATEST .
          
          echo "âœ… Docker image built successfully"
          docker images | grep "${{ env.DOCKER_IMAGE_NAME }}"

      - name: ðŸ’¾ Save Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar"
          
          echo "ðŸ’¾ Saving Docker image to $IMAGE_FILE..."
          docker save $IMAGE_TAG -o $IMAGE_FILE
          
          # Compress the image to reduce size
          echo "ðŸ—œï¸ Compressing image..."
          gzip -f $IMAGE_FILE
          
          echo "âœ… Image saved and compressed: ${IMAGE_FILE}.gz"
          ls -lh ${IMAGE_FILE}.gz

      - name: ðŸ“¤ Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: docker-image-${{ needs.setup.outputs.sha }}.tar.gz
          retention-days: 1
          compression-level: 0

      - name: ðŸ“Š Build summary
        run: |
          echo "### ðŸ—ï¸ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Name:** ${{ env.DOCKER_IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 3: Deploy - SSH to EC2 and Deploy
  # ============================================
  deploy:
    name: ðŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: ./

      - name: ðŸ” Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: ðŸ” Test SSH connection
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          timeout: 60s
          command_timeout: 30s
          script: |
            echo "âœ… SSH connection successful!"
            echo "Hostname: $(hostname)"
            echo "User: $(whoami)"
            echo "Current directory: $(pwd)"

      - name: ðŸš€ Deploy to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "docker-image-${{ needs.setup.outputs.sha }}.tar.gz,docker-compose.yml"
          target: ${{ env.APP_DIR }}
          timeout: 300s
          command_timeout: 300s
          debug: true
          strip_components: 0
          overwrite: true

      - name: ðŸ³ Deploy Docker containers
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          timeout: 600s
          command_timeout: 600s
          debug: true
          script: |
            set -e
            
            APP_DIR="${{ env.APP_DIR }}"
            IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
            IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar.gz"
            
            echo "ðŸš€ Starting deployment..."
            
            # Create app directory if it doesn't exist
            mkdir -p $APP_DIR
            cd $APP_DIR
            
            # Ensure Docker and Docker Compose are installed
            if ! command -v docker &> /dev/null; then
              echo ">> Docker o'rnatilmagan, o'rnatilmoqda..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
              echo ">> Docker muvaffaqiyatli o'rnatildi"
            else
              echo ">> Docker allaqachon o'rnatilgan"
            fi
            
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo ">> Docker Compose o'rnatilmagan, o'rnatilmoqda..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
              echo ">> Docker Compose muvaffaqiyatli o'rnatildi"
            else
              echo ">> Docker Compose allaqachon o'rnatilgan"
            fi
            
            # Load Docker image (use sudo if needed, or newgrp for docker group)
            echo "ðŸ“¥ Loading Docker image..."
            if groups | grep -q docker; then
              DOCKER_CMD="docker"
              COMPOSE_CMD="docker-compose"
            else
              DOCKER_CMD="sudo docker"
              COMPOSE_CMD="sudo docker-compose"
              echo "âš ï¸ Using sudo for docker commands (user not in docker group yet)"
            fi
            
            gunzip -c $IMAGE_FILE | $DOCKER_CMD load
            $DOCKER_CMD tag $IMAGE_TAG ${{ env.DOCKER_IMAGE_NAME }}:latest
            echo "âœ… Docker image loaded successfully"
            
            # Stop old containers
            echo "ðŸ›‘ Stopping old containers..."
            if [ -f docker-compose.yml ]; then
              $COMPOSE_CMD down || true
            fi
            
            # Create .env file
            echo "ðŸ“ Creating .env file..."
            cat > .env << EOF
            # Telegram Bot Configuration
            BOT_TOKEN=${{ secrets.BOT_TOKEN }}
            
            # SUPER_ADMIN Configuration
            SUPER_ADMIN_USERNAME=${{ vars.SUPER_ADMIN_USERNAME }}
            SUPER_ADMIN_PASSWORD=${{ secrets.SUPER_ADMIN_PASSWORD }}
            SUPER_ADMIN_NAME=${{ vars.SUPER_ADMIN_NAME }}
            SUPER_ADMIN_PHONE=${{ vars.SUPER_ADMIN_PHONE }}
            
            # Token
            JWT_TOKEN_SECRET=${{ secrets.JWT_TOKEN_SECRET }}
            JWT_TOKEN_EXPIRATION=${{ vars.JWT_TOKEN_EXPIRATION }}
            
            # Database Configuration (Docker Compose service nomi)
            DB_HOST=db
            DB_PORT=${{ vars.DB_PORT }}
            DB_USERNAME=${{ vars.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ vars.DB_DATABASE }}
            
            # Application Port
            PORT=${{ vars.PORT }}
            NODE_ENV=production
            EOF
            
            # Update docker-compose.yml to use image instead of build
            echo "ðŸ”§ Updating docker-compose.yml to use pre-built image..."
            IMAGE_NAME="${{ env.DOCKER_IMAGE_NAME }}:latest"
            # Use awk to replace build section with image (more reliable than sed for multi-line)
            awk -v img="$IMAGE_NAME" '
            /^  app:/ { in_app=1; print; next }
            in_app && /^    build:/ { 
              print "    image: " img
              skip_build=1
              next
            }
            skip_build && /^      (context|dockerfile):/ { next }
            skip_build && /^    [a-z]/ { skip_build=0; in_app=0 }
            { print }
            ' docker-compose.yml > docker-compose.yml.tmp && mv docker-compose.yml.tmp docker-compose.yml
            echo "âœ… docker-compose.yml updated to use image: $IMAGE_NAME"
            
            # Clean up old images
            echo "ðŸ§¹ Cleaning up old images..."
            $DOCKER_CMD image prune -f || true
            
            # Start containers
            echo "ðŸš€ Starting containers..."
            $COMPOSE_CMD up -d
            
            # Wait for database to be ready
            echo "â³ Waiting for database to be ready..."
            timeout=60
            counter=0
            while ! $COMPOSE_CMD exec -T db pg_isready -U ${{ vars.DB_USERNAME }} > /dev/null 2>&1; do
              if [ $counter -ge $timeout ]; then
                echo "âŒ Database container tayyor bo'lmadi!"
                exit 1
              fi
              echo "Database kutilyapti... ($counter/$timeout)"
              sleep 2
              counter=$((counter + 2))
            done
            echo "âœ… Database container tayyor!"
            
            # Show container status
            echo "ðŸ“Š Container status:"
            $COMPOSE_CMD ps
            
            # Show database volume info
            echo "ðŸ’¾ Database volume info:"
            $DOCKER_CMD volume inspect postgres_data 2>/dev/null || echo "Volume info not available"
            
            echo "âœ… Deployment completed successfully!"

      - name: ðŸ“Š Deployment summary
        run: |
          echo "### ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Server:** ${{ secrets.DEPLOY_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** http://${{ secrets.DEPLOY_HOST }}:${{ vars.PORT }}" >> $GITHUB_STEP_SUMMARY
