name: CI/CD Pipeline

on:
  push:
    branches:
      - main

env:
  NODE_VERSION: '20'
  DOCKER_IMAGE_NAME: barbershop-bot
  APP_DIR: ${{ vars.APP_DIR || '/home/ubuntu/barbershop-bot' }}

jobs:
  # ============================================
  # Job 1: Setup - Checkout and Verify
  # ============================================
  setup:
    name: Setup & Verify
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.branch.outputs.name }}
      sha: ${{ steps.sha.outputs.short }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get branch name
        id: branch
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "name=${{ github.head_ref }}" >> $GITHUB_OUTPUT
          else
            echo "name=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          fi

      - name: Get short SHA
        id: sha
        run: echo "short=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Verify branch
        run: |
          BRANCH="${{ steps.branch.outputs.name }}"
          echo "Current branch: $BRANCH"
          if [ "${{ github.event_name }}" = "push" ] && [ "$BRANCH" != "main" ]; then
            echo "Warning: Not on main branch, but continuing..."
          fi
          echo "Branch verification passed"

      - name: Workflow info
        run: |
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ steps.branch.outputs.name }}"
          echo "Commit SHA: ${{ steps.sha.outputs.short }}"
          echo "Event: ${{ github.event_name }}"

  # ============================================
  # Job 2: Build - Install, Build, Save Image
  # ============================================
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.meta.outputs.digest }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          echo "Installing dependencies..."
          npm ci
          echo "Dependencies installed successfully"

      - name: Build application
        run: |
          echo "Building application..."
          npm run build
          echo "Application built successfully"

      - name: Extract metadata
        id: meta
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          echo "tags=$IMAGE_TAG,$IMAGE_LATEST" >> $GITHUB_OUTPUT
          echo "Image tags: $IMAGE_TAG, $IMAGE_LATEST"

      - name: Build Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
          
          echo "Building Docker image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG -t $IMAGE_LATEST .
          
          echo "Docker image built successfully"
          docker images | grep "${{ env.DOCKER_IMAGE_NAME }}"

      - name: Save Docker image
        run: |
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
          IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar"
          
          echo "Saving Docker image to $IMAGE_FILE..."
          docker save $IMAGE_TAG -o $IMAGE_FILE
          
          # Compress the image to reduce size
          echo "Compressing image..."
          gzip -f $IMAGE_FILE
          
          echo "Image saved and compressed: ${IMAGE_FILE}.gz"
          ls -lh ${IMAGE_FILE}.gz

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: docker-image-${{ needs.setup.outputs.sha }}.tar.gz
          retention-days: 1
          compression-level: 0

      - name: Build summary
        run: |
          echo "### Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Name:** ${{ env.DOCKER_IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 3: Deploy - SSH to EC2 and Deploy
  # ============================================
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [setup, build]
    # Faqat main branch'dan push bo'lganda deploy qilish
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && github.ref_name == 'main'
    environment:
      name: production
    steps:
      - name: Verify deployment conditions
        run: |
          if [ "${{ github.ref }}" != "refs/heads/main" ]; then
            echo "❌ ERROR: Deployment is only allowed from main branch!"
            echo "Current branch: ${{ github.ref }}"
            exit 1
          fi
          echo "✅ Branch verification passed: Deploying from main branch"
          echo "Branch: ${{ github.ref_name }}"
          echo "Event: ${{ github.event_name }}"
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ needs.setup.outputs.sha }}
          path: ./

      - name: Create target directory on server
        uses: appleboy/ssh-action@v1.0.3
        continue-on-error: true
        with:
          host: 51.20.251.136
          username: ubuntu
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          timeout: 120s
          command_timeout: 120s
          debug: true
          script: |
            mkdir -p ${{ env.APP_DIR }}
            cd ${{ env.APP_DIR }}
            echo "Directory created: ${{ env.APP_DIR }}"
            echo "Current directory: $(pwd)"
            echo "User: $(whoami)"
            echo "Hostname: $(hostname)"

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        continue-on-error: true
        with:
          host: 51.20.251.136
          username: ubuntu
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          source: "docker-image-${{ needs.setup.outputs.sha }}.tar.gz,docker-compose.yml"
          target: ${{ env.APP_DIR }}
          timeout: 120s
          command_timeout: 10m
          debug: true
          strip_components: 0
          overwrite: true

      - name: Deploy Docker containers
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: 51.20.251.136
          username: ubuntu
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          timeout: 120s
          command_timeout: 10m
          debug: true
          script: |
            cd ${{ env.APP_DIR }}
            
            # Install Docker if not installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
              echo "Docker installed successfully"
            else
              echo "Docker is already installed"
              docker --version
            fi
            
            # Install Docker Compose if not installed
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
              echo "Docker Compose installed successfully"
            else
              echo "Docker Compose is already installed"
              docker compose version || docker-compose --version
            fi
            
            # Verify files
            echo "Verifying files..."
            ls -l || echo "Directory listing failed"
            ls -l docker-compose.yml || echo "docker-compose.yml not found"
            ls -l docker-image-*.tar.gz || echo "Docker image file not found"
            
            # Determine docker command (with or without sudo)
            if groups | grep -q docker; then
              DOCKER_CMD="docker"
              COMPOSE_CMD="docker compose"
            else
              DOCKER_CMD="sudo docker"
              COMPOSE_CMD="sudo docker compose"
            fi
            
            # Stop old containers
            echo "Stopping old containers..."
            $COMPOSE_CMD down || true
            
            # Load Docker image - to'g'ri faylni topish
            IMAGE_FILE="docker-image-${{ needs.setup.outputs.sha }}.tar.gz"
            IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}"
            IMAGE_LATEST="${{ env.DOCKER_IMAGE_NAME }}:latest"
            
            if [ ! -f "$IMAGE_FILE" ]; then
              echo "ERROR: Image file not found: $IMAGE_FILE"
              echo "Available files:"
              ls -la docker-image-*.tar.gz || echo "No image files found"
              exit 1
            fi
            
            echo "Loading Docker image: $IMAGE_FILE"
            gunzip -c $IMAGE_FILE | $DOCKER_CMD load
            
            # Yuklangan image nomini tekshirish va tag qilish
            echo "Tagging image..."
            $DOCKER_CMD tag $IMAGE_TAG $IMAGE_LATEST || {
              # Agar tag mavjud bo'lmasa, yuklangan image nomini topish
              LOADED_IMAGE=$($DOCKER_CMD images --format "{{.Repository}}:{{.Tag}}" | grep "${{ env.DOCKER_IMAGE_NAME }}" | head -1)
              if [ -n "$LOADED_IMAGE" ]; then
                echo "Found loaded image: $LOADED_IMAGE, tagging as $IMAGE_LATEST"
                $DOCKER_CMD tag $LOADED_IMAGE $IMAGE_LATEST
              else
                echo "ERROR: Could not find loaded image"
                $DOCKER_CMD images
                exit 1
              fi
            }
            
            echo "Docker image loaded and tagged successfully"
            $DOCKER_CMD images | grep "${{ env.DOCKER_IMAGE_NAME }}"
            
            # Create .env file
            echo "Creating .env file..."
            echo "BOT_TOKEN=${{ secrets.BOT_TOKEN }}" > .env
            echo "SUPER_ADMIN_USERNAME=${{ vars.SUPER_ADMIN_USERNAME }}" >> .env
            echo "SUPER_ADMIN_PASSWORD=${{ secrets.SUPER_ADMIN_PASSWORD }}" >> .env
            echo "SUPER_ADMIN_NAME=${{ vars.SUPER_ADMIN_NAME }}" >> .env
            echo "SUPER_ADMIN_PHONE=${{ vars.SUPER_ADMIN_PHONE }}" >> .env
            echo "JWT_TOKEN_SECRET=${{ secrets.JWT_TOKEN_SECRET }}" >> .env
            echo "JWT_TOKEN_EXPIRATION=${{ vars.JWT_TOKEN_EXPIRATION }}" >> .env
            echo "DB_HOST=db" >> .env
            echo "DB_PORT=${{ vars.DB_PORT }}" >> .env
            echo "DB_USERNAME=${{ vars.DB_USERNAME }}" >> .env
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            echo "DB_DATABASE=${{ vars.DB_DATABASE }}" >> .env
            echo "DB_SYNCHRONIZE=false" >> .env
            echo "PORT=${{ vars.PORT }}" >> .env
            echo "NODE_ENV=production" >> .env
            
            # Fix line endings (Windows compatibility)
            sudo apt-get update && sudo apt-get install -y dos2unix || echo "dos2unix installation failed"
            dos2unix .env || echo "dos2unix conversion failed"
            
            cat .env
            
            # Update docker-compose.yml to use image instead of build
            echo "Updating docker-compose.yml..."
            IMAGE_NAME="${{ env.DOCKER_IMAGE_NAME }}:latest"
            if [ -f docker-compose.yml ]; then
              awk -v img="$IMAGE_NAME" '
              /^  app:/ { in_app=1; print; next }
              in_app && /^    build:/ { 
                print "    image: " img
                skip_build=1
                next
              }
              skip_build && /^      (context|dockerfile):/ { next }
              skip_build && /^    [a-z]/ { skip_build=0; in_app=0 }
              { print }
              ' docker-compose.yml > docker-compose.yml.tmp && mv docker-compose.yml.tmp docker-compose.yml
              echo "docker-compose.yml updated successfully"
            else
              echo "ERROR: docker-compose.yml not found!"
              exit 1
            fi
            
            # Verify docker-compose config
            echo "Verifying docker-compose configuration..."
            $COMPOSE_CMD config || {
              echo "ERROR: docker-compose config validation failed!"
              exit 1
            }
            
            # Clean up old images (but keep the current one)
            echo "Cleaning up old images..."
            $DOCKER_CMD image prune -f || echo "Docker image prune failed"
            
            # Start containers (no build needed, image already loaded)
            echo "Starting containers..."
            if ! $COMPOSE_CMD up -d; then
              echo "ERROR: Failed to start containers!"
              echo "Container status:"
              $DOCKER_CMD ps -a
              echo "Docker compose logs:"
              $COMPOSE_CMD logs || true
              echo "Docker images:"
              $DOCKER_CMD images | grep "${{ env.DOCKER_IMAGE_NAME }}" || true
              exit 1
            fi
            
            # Wait for database to be ready
            echo "Waiting for database to be ready..."
            DB_USER="${{ vars.DB_USERNAME || 'postgres' }}"
            timeout=60
            counter=0
            while ! $COMPOSE_CMD exec -T db pg_isready -U $DB_USER > /dev/null 2>&1; do
              if [ $counter -ge $timeout ]; then
                echo "ERROR: Database container not ready after $timeout seconds!"
                $COMPOSE_CMD logs db
                exit 1
              fi
              echo "Waiting for database... ($counter/$timeout seconds)"
              sleep 2
              counter=$((counter + 2))
            done
            echo "Database is ready!"
            
            # Run database migrations
            echo "=========================================="
            echo "Running database migrations..."
            echo "=========================================="
            if $COMPOSE_CMD exec -T app npm run migration:run; then
              echo "✅ Migrations completed successfully!"
            else
              echo "⚠️ Warning: Migration command failed, but continuing..."
              echo "Note: This might be expected if migrations have already run."
              echo "Check logs for details:"
              $COMPOSE_CMD logs --tail=30 app
            fi
            
            # Show migration status
            echo "=========================================="
            echo "Migration status:"
            echo "=========================================="
            $COMPOSE_CMD exec -T app npm run migration:show || echo "Could not show migration status"
            
            # Wait a bit for app to start
            echo "Waiting for application to start..."
            sleep 5
            
            # Show container status
            echo "=========================================="
            echo "Container status:"
            echo "=========================================="
            $DOCKER_CMD ps -a
            
            # Show logs
            echo "=========================================="
            echo "Application logs (last 50 lines):"
            echo "=========================================="
            $COMPOSE_CMD logs --tail=50 app || echo "No app container logs"
            
            echo "=========================================="
            echo "Database logs (last 20 lines):"
            echo "=========================================="
            $COMPOSE_CMD logs --tail=20 db || echo "No db container logs"
            
            # Final health check
            echo "=========================================="
            echo "Health check:"
            echo "=========================================="
            APP_CONTAINER=$($DOCKER_CMD ps -q --filter "name=barbershop-bot")
            if [ -n "$APP_CONTAINER" ]; then
              echo "App container is running: $APP_CONTAINER"
              $DOCKER_CMD inspect --format='{{.State.Status}}' $APP_CONTAINER
            else
              echo "WARNING: App container not found!"
            fi
            
            DB_CONTAINER=$($DOCKER_CMD ps -q --filter "name=barbershop-db")
            if [ -n "$DB_CONTAINER" ]; then
              echo "DB container is running: $DB_CONTAINER"
              $DOCKER_CMD inspect --format='{{.State.Status}}' $DB_CONTAINER
            else
              echo "WARNING: DB container not found!"
            fi
            
            echo "=========================================="
            echo "✅ Deployment completed successfully!"
            echo "=========================================="

      - name: Deployment summary
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Server:** ${{ secrets.DEPLOY_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.setup.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** http://${{ secrets.DEPLOY_HOST }}:${{ vars.PORT }}" >> $GITHUB_STEP_SUMMARY
